EMAlg.pspline.large <- function(data, deg=2, EMmaxit = 20, ncomps = 4, z=z, random=NULL,                                 est=NULL, n.time=NULL, knots=NULL, thresh=NULL){
                                	
    # data = dataframe containing the data.
    # deg = degree of the truncated power basis. Default to p = 2.
    # EMmaxit = the maximum number of iterations for the RCEM step.
    # ncomps = the number of clusters to fit.
    # z = matrix of posterior probabilities.
    # random = where to specify the random effects structure. Specifying random = "1|indiv" fits a random intercept 
    # for each gene.
    # est = specify whether to use "ML" or "REML" to fit the mixed model. Typically choose "REML".
    # n.time = number of timepoints each gene is measured at.
    # knots = location of the knots. Calculated using default.knots function.
    # thresh = threshold (c) for RCEM step.        # Function to calculate the density of each gene in each component.    my.fun <- function(x, rand, my.var){      tmp <- na.omit(x)      if(!is.null(rand))         V <- diag(my.var[1],nrow(tmp))+matrix(1,nrow=nrow(tmp), ncol=nrow(tmp))*my.var[2]      else         V <- diag(my.var,nrow(tmp))      dmvnorm(tmp[,1], tmp[,2], V)    }        # Function to perform RCEM step.    fun.weights <- function(x, thresh){        below.thresh <- which(x < thresh)  # Pick out genes in each component with weights below threshold, c.        my.remain <- x[below.thresh]        if(length(my.remain)==0)  # If no gene below c, return original weights.            x        else{ # If any gene below c, select genes with prob x/thresh.          sem.select <- as.vector(tapply(my.remain, 1:length(my.remain), function(my.exp, p=thresh) sample(c(1,0), 1, prob=c(my.exp/p, (1 - my.exp/p)))))          label <- below.thresh[which(sem.select==1)]          label2 <- below.thresh[which(sem.select==0)]          x[label] <- thresh              x[label2] <- 0          x        }    }            fits <- list()    loglikelihood <- c()    var.comps <- list()    bic <- c()    pai <- c()        if(est == "ML")        REML <- FALSE    else        REML <- TRUE        if(is.null(thresh)) thresh <- 0.5 # Set the threshold for RCEM step.        N <- nrow(data)                 # Initial estimate for component weights    pai <- apply(z,2,sum)/sum(z)        prop <- matrix(0, nrow=length(unique(data$indiv)),ncol=ncomps)    ind.prop <- matrix(0, nrow=length(unique(data$indiv)),ncol=ncomps)        # Fit P-spline model to data in each cluster to get initial estimates of mu and sigma.    for(g in 1:ncomps){        f <- c()        temp <- data.frame(data, weight=z[,g])        comp.data <- temp[which(!is.na(temp$y)),] # Remove NA values if present.        # Initial fit (the P-spline smooth to data (mean and random effects)).         if(!is.null(random)){            assign("model.basis",  y ~ tp(x=time, degree=deg, knots = knots),pos=1)            assign("new.model",update(model.basis, as.formula(paste(". ~ . + (", random, ")"))),pos=1)            f1 <- amer(new.model, data=comp.data[comp.data$weight!=0,], REML=REML, weights=weight)  # P-spline fit.            ranef.var <- (VarCorr(f1)[[1]][1])*sum(comp.data$weight)/f1@dims["n"]            error.var <- (expand(f1)$sigma^2)            var <- c(error.var, ranef.var)   # Extract the variance estimates for the residual and random effect term.                                                     }        else{            # Fit the P-spline smooth to data (mean only).             f1 <- amer(y ~ tp(x=time, degree=deg, knots = knots), data=comp.data[comp.data$weight!=0,], REML=REML, 
            weights=weight)            var <- (expand(f1)$sigma)^2    # Extract the standard deviation estimates for the error term.        }        fits[[g]] <- f1        var.comps[[g]] <- var                my.fit <- getF(f1, newdata=comp.data)   # Get the fitted values in each component.        f <- c(by(cbind(comp.data$y, my.fit$f.time[[1]]$fhat), factor(comp.data$indiv), my.fun,                      rand=random, my.var=var))   # Calculate the density for each gene in each component.                           prop[,g] <- f    ind.prop[,g] <- prop[,g]*pai[g]    }    ind.lik <- apply(ind.prop, 1, sum)    ind.log.lik <- log(ind.lik)   # Calculate the log-likelihood.        print(current.like <- sum(ind.log.lik))    loglikelihood[1] <- current.like        tmp <- ind.prop/ind.lik   # Calculate the posterior weights.    tmp[which(ind.lik==0),] <- 1/ncomps   # Check if all posterior weights are zero. If so, assign weight of 1/ncomps to each component.    expz <- apply(tmp,2,fun.weights, thresh=thresh)  # Perform RCEM step.    all.zero <- which(rowSums(expz) == 0)  # Check if all weights after EM step are zero.     expz[all.zero,] <- tmp[all.zero,]  # If so, assign original weights.    expz <- matrix(apply(expz,1,function(x) x/sum(x)), ncol=ncomps, byrow=T) # Re-normalizing weights after RCEM step.        out.fits <- fits    out.expz <- tmp    out.var <- var.comps    out.like <- current.like        # EM algorithm     iter <- 1        ##########Start of EM ##########    while (iter <= EMmaxit){        print(iter)                pai <- apply(tmp, 2, sum)/sum(tmp)        prop <- matrix(0, nrow=length(unique(data$indiv)),ncol=ncomps)        ind.prop <- matrix(0, nrow=length(unique(data$indiv)),ncol=ncomps)        for(g in 1:ncomps){  # For each component fit a P-spline to the data, get the fitted values and calculate the variance structure.                        f <- c()            temp <- data.frame(data, weight=rep(expz[,g], each=n.time))            comp.data <- temp[which(!is.na(temp$y)),]   # Remove NA values if present.                         # P-spline fit to data (mean and random effects)).             if(!is.null(random)){                                assign("model.basis",  y ~ tp(x=time, degree=deg, knots = knots),pos=1)                assign("new.model",update(model.basis, as.formula(paste(". ~ . + (", random, ")"))),pos=1)                f1 <- amer(new.model, data=comp.data[comp.data$weight!=0,], REML=REML, weights=weight)                 ranef.var <- (VarCorr(f1)[[1]][1])*sum(comp.data$weight)/f1@dims["n"]                error.var <- (expand(f1)$sigma^2)                var <- c(error.var, ranef.var)  # Extract the standard deviation estimates for the residual                                                # and random effect terms.            }            else {                # Fit the P-spline smooth to data (mean only).                 f1 <- amer(y ~ tp(x=time, degree=deg, knots = knots), data=comp.data[comp.data$weight!=0,], REML=REML,
                weights=weight)                var <- (expand(f1)$sigma)^2     # Extract the standard deviation estimate for the error.            }            fits[[g]] <- f1            var.comps[[g]] <- var                    my.fit <- getF(f1, newdata=comp.data)  # Get the fitted values in the gth component.            f <- c(by(cbind(comp.data$y, my.fit$f.time[[1]]$fhat), factor(comp.data$indiv),                           my.fun, rand=random, my.var=var))  # Calculate the density of each gene in each component.                        prop[,g] <- f        ind.prop[,g] <- prop[,g]*pai[g]        }        ind.lik <- apply(ind.prop, 1, sum)        ind.log.lik <- log(ind.lik) # Calculate the log-likelihood.        print(current.like <- sum(ind.log.lik))                        tmp <- ind.prop/ind.lik # Calculate the posterior weights.        tmp[which(ind.lik==0),] <- 1/ncomps  # Check if all posterior weights are zero. If so, assign weight of 1/ncomps to each component.        expz <- apply(tmp,2,fun.weights, thresh=thresh) # Perform RCEM step.        all.zero <- which(rowSums(expz) == 0) # Check if all weights after EM step are zero.         expz[all.zero,] <- tmp[all.zero,]  # If so, assign original weights.        expz <- matrix(apply(expz,1,function(x) x/sum(x)), ncol=ncomps, byrow=T) # Re-normalizing weights after RCEM step.                      if(current.like > max(loglikelihood)){  # Store results if loglikelihood increases.           out.fits <- fits           out.expz <- tmp           out.var <- var.comps           out.like <- current.like        }        loglikelihood[iter+1] <- current.like        iter <- iter + 1                        }     n.params <- ncomps*ncol(attributes(fits[[1]])$X) + 4*ncomps - 1    fit.BIC <- -2*out.like + log(length(na.omit(data$y)))*n.params    return(list(fit=out.fits, z=Matrix(round(out.expz,2),sparse=T), L=out.like, vars=out.var, BIC=fit.BIC))}   